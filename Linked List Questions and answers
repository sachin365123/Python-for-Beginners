Linked List Questions and answers
Q.1. Write an algorithm to find the location of an element in the given Linked List. Is the binary search will be suitable for this search? Explain the reason.
Sol. As Linked List does not have sequence of element in linear format so one will have to Generate a  while loop by traversing all nodes comparing the data with K which is the element to search in Linked Link.
Algorithm SEARCH_Node_Linked List (K, Head) // Name of the Function
Begin t=0                       // Variable initialize which will be updated only when K is found
current =head               // Initially pointer points to head of the Linked List 
while (current !=null)   //Till end of LL
{
 if(current ->info=K       // Data of the node
 { t=1 break } 
current=current->next 
} 
if(t=1) 
print ”Element found” 
else
print “Not found" End.   //End of the Algorithm

Use of binary Search in Linked List: it is worthless to use Binary Search in LL in order to find element as time complexity will be O(n), because it is tedious task to find out the middle node of any LL which is pre-requisiteness of Binary Search. 

Q.2. Write down an algorithm to delete a node from doubly Linked List.

Sol. Following is the representation of doubly Linked List consisting the header, Next Node, Previous Node address in front and rear part of each node. 

 
Image Courtesy: https://www.geeksforgeeks.org/delete-a-node-in-a-doubly-linked-list/ 

Algorithm to delete node from any position
%% Input : head {Pointer to the first node of the list}
         last {Pointer to the last node of the list}
         N {Position to be deleted from list}
Begin:
    current ← head;
    For i ← 1 to N and current != NULL do
        current ← current.next;
    End for
    If (N == 1) then
        deleteFromBeginning()
    End if
    Else if (current == last) then 
        deleteFromEnd()
    End if
    Else if (current != NULL) then
        current.prev.next ← current.next
        If (current.next != NULL) then
            current.next.prev ← current.prev;
        End if
        unalloc (current)
        write ('Node deleted successfully from ', N, ' position')
    End if
    Else then
        write ('Invalid position')
    End if
End

In the above algorithm, if node to be deleted is first node then delete first node algorithm will be invoked, in case last node pointer last node will be deleted, now for the any node:

current.prev.next ← current.next
        If (current.next != NULL) then
            current.next.prev ← current.prev;
Address of next node of current will be stored in previous node, in next step; address of previous node will be assign in next node of current node. 
